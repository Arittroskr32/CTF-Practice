from sympy import mod_inverse

# Given p, q, e, and ciphertext (ct)
p = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591

q = 171731371218065444125482536302245915415603318380280392385291836472299752747934607246477508507827284075763910264995326010251268493630501989810855418416643352631102434317900028697993224868629935657273062472544675693365930943308086634291936846505861203914449338007760990051788980485462592823446469606824421932591

e = 65537  

ct = 161367550346730604451454756189028938964941280347662098798775466019463375610700074840105776873791605070092554650190486030367121011578171525759600774739890458414593857709994072516290998135846956596662071379067305011746842247628316996977338024343628757374524136260758515864509435302781735938531030576289086798942

# Step 1: Compute N
N = p * q

# Step 2: Compute φ(N) = (p-1)(q-1)
phi_N = (p - 1) * (q - 1)

# Step 3: Compute the private key d (modular inverse of e mod φ(N))
d = mod_inverse(e, phi_N)

# Step 4: Decrypt the ciphertext using the private key d
m = pow(ct, d, N)

# Convert the decrypted message back to text (assuming it's ASCII encoded)
# If the plaintext is an integer that represents ASCII, convert it
decrypted_message = hex(m)[2:]  # Convert to hex format to see the message

# Printing the decrypted message in hexadecimal format
print("Decrypted message (hex format):", decrypted_message)
