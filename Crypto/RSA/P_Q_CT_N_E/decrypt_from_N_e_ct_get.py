from sympy import mod_inverse, factorint

# Given values of N, e, ct
N =  22363547196442286210426096667664934311317202577331708826153312267732060185205433048808318440463775968421571822227366261954714323978290561533582199565520788429312336490136251056698920021717041035283985925620392112442824974178172021230849595039039306862922738621825885516779477934926848831948958100398352376077348421245571051324795910162119087349950756020138069248337386146521430971157062177977730152042384068692748838755054309828353321199177441035894790043246481449883627784291325743830605685598965856794606303061786664661856150516456672469573269821203622123914965529899157206838756880892870142776988576626372988177707
e =  19822480419274488251677307922322581373608204916680174673515561360377028968995622607105335755414698144839412875613842080380230300482081946559177683666445909117111224336011873134132068056373656982714080443846061013910593976113415924274483397122945817679487981728613001314822288629582438110592231444108617950478126633605615041008363059448762655342571466013321463018102191788621452554997775676351436919999398565010668785252540431172512816473968178117862553874600835604298639910296325807391721223375419556418763943323750839521188471388175040976788107840583526861438993050030109324607729519719906931135902316161956554417247
ct =  20669994708006374492332408443552994657565024584499882198289881629327456420131652672644195100224053344721432610837542380690357511678554165977862585280690124064940265866331188493388139401890080777144048642545824690638711647662716274477313756119089469571437167537744610125087365250237016433614437143205669272935236970816786349219410512180413748838352810769828299391984432764737699871315273441061688230054282620365310525349403179845974997292082725104491895789767803968213625826443284286992971970312958113034411043760948189789647338123641981837034546966566836079032985552217182778034237303636695098968553870135569293791141


# Step 1: Try factoring N into p and q
# Use factorint from sympy to get factors of N
factors = factorint(N)

# Check if the factors dictionary has one or two keys
if len(factors) == 1:
    # If only one key is returned, we assume p = q
    p = list(factors.keys())[0]
    q = p  # p and q are the same
    print(f"Single factor found: p = q = {p}")
elif len(factors) == 2:
    # If two factors are found, assign p and q
    p = list(factors.keys())[0]
    q = list(factors.keys())[1]
    print(f"Factors found: p = {p}, q = {q}")
else:
    print(f"Factorization did not return exactly one or two factors. Found {len(factors)} factors.")
    print("Factors found:", factors)
    exit()

# Step 2: Compute φ(N) = (p-1)(q-1)
phi_N = (p - 1) * (q - 1)

# Step 3: Compute the private key d (modular inverse of e mod φ(N))
d = mod_inverse(e, phi_N)

# Step 4: Decrypt the ciphertext using the private key d
m = pow(ct, d, N)

# Convert the decrypted message back to text (assuming it's ASCII encoded)
try:
    decrypted_message = hex(m)[2:]  # Convert to hex format to see the message
    print("Decrypted message (hex format):", decrypted_message)
    
    # If the decrypted message corresponds to ASCII values, convert it to string
    byte_message = bytes.fromhex(decrypted_message)
    decrypted_text = byte_message.decode('utf-8')
    print("Decrypted message (text):", decrypted_text)
except Exception as e:
    print(f"Error while converting decrypted message: {e}")
